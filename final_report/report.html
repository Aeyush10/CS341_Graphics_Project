<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>A Whole New World</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="icg_report.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">A Whole New World</h1>
</header>
<figure>
<video autoplay controls width="600">
<source src="images/bezier_3.mov">
<a href="images/bezier_3.mov">Summary of the project features</a></video>
<figcaption aria-hidden="true">
Summary of the project features
</figcaption>
</figure>
<h1 id="abstract">Abstract</h1>
<p>A visually interesting and infinitely procedurally generated
landscape is generated using the code of exercise PG1 as a base and
adding the six following elements to it:</p>
<ol type="1">
<li>Creation of infinite terrain: as opposed to the static landscape in
the exercise code, we generate an infinite landscape.</li>
<li>Shader implementation: In contrast to the exercise code, where
normals were being calculated in the javascript files using the mesh
points, we use analytic normals by using the derivative of the noise
function in the shader.</li>
<li>Animated waves: we add waves onto the water to give a live effect
using 3D Perlin noise rather than 2D noise from the exercise.</li>
<li>Camera movement: we implement camera paths using Bézier curves for a
cinematic view of the terrain.</li>
<li>Trees and birds: we add randomly scattered trees of different shape
and sizes and birds with random velocities using instance
rendering.</li>
<li>Reflection of sky in water: We use a 3D cubemap to give a reflective
view to the water.</li>
</ol>
<h1 id="technical-approach">Technical Approach</h1>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>Setting terrain shape in vertex shader</strong>
</summary>
<p>In the original code of PG1 exercise, there was a buffer which stored
the values of elevation of the terrain (the elevation was calculated
using the noise functions of perlin noise). But now I eliminate the use
of buffer altogether and calculate the elevation inside the
terrain.vert.glsl file. To achieve this, I first import the code for
noise from PG1 exercise into the terrain.vert.glsl file and then
calculate the elevation using the noise function. The tricky part here
was understanding the GPU pipeline.</p>
<h3 id="code">Code</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> local_coord <span class="op">=</span>  <span class="fl">2.</span> <span class="op">*</span> position<span class="op">.</span><span class="fu">xy</span> <span class="op">*</span> viewer_scale<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v2f_tex_coords <span class="op">=</span> viewer_position <span class="op">+</span> local_coord<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> noise_value <span class="op">=</span> <span class="fu">tex_fbm_for_terrain</span><span class="op">(</span>v2f_tex_coords<span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">// noise value lies in the range (0,1) so we subtract 0.5 to get it in the range (-0.5,0.5)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>v2f_height <span class="op">=</span> noise_value<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span></code></pre></div>
<p>The above code, present in <code>terrain.vert.glsl</code>
demonstrates this. The first line calculates the local coordinates of a
vertex of the mesh of the terrain. The <code>2.</code> is multiplied to
convert the points from <code>(-0.5, 0.5)</code> to
<code>(-1, 1)</code>. In the next line, the local position is offset by
the viewer position to get the global coordinates. Finally in line 3
noise function is invoked to get the noise value. And in line 4, the
noise value is converted from <code>(0, 1)</code> to
<code>(-0.5, 0.5)</code>. The end result is that the variable
<code>v2f_height</code> holds the value of elevation at a given
point.</p>
</details>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>Calculating the normals in the shader</strong>
</summary>
<p>In the exercise PG1 code, the normals are calculated in the
JavaScript files by taking the approximate derivatives. Now I use the
derivative of the perlin noise function to calculate the normals inside
the terrain.vert.glsl file. The expression for derivative in perlin
noise was taken from a resource on the internet.</p>
<p>It is to be noted that the terrain elevation is not calculated using
the perlin noise, but instead using the function
<code>tex_fbm_for_terrain</code> from the exercise code. So the
derivative of Perlin Noise had to be propagated through the functions
<code>perlin_fbm</code> and <code>tex_fbm_for_terrain</code> which I did
myself.</p>
<h3 id="code-1">Code</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> <span class="fu">perlin_fbm</span><span class="op">(</span><span class="dt">vec2</span> point<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>      <span class="dt">vec3</span> fbm <span class="op">=</span> <span class="fu">perlin_noise</span><span class="op">(</span>point<span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">float</span> a <span class="op">=</span> ampl_multiplier<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">float</span> omega <span class="op">=</span> freq_multiplier<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> num_octaves<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> new_octave <span class="op">=</span> a <span class="op">*</span> <span class="fu">perlin_noise</span><span class="op">(</span>point <span class="op">*</span> omega<span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// new_octave.yz has to be multiplied by omega in accordance with chain rule</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        fbm <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span>new_octave<span class="op">.</span><span class="fu">x</span><span class="op">,</span> new_octave<span class="op">.</span><span class="fu">yz</span> <span class="op">*</span> omega<span class="op">);</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> a <span class="op">*</span> a<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        omega <span class="op">=</span> omega <span class="op">*</span> omega<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">return</span> fbm<span class="op">;</span>   </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vec3</span> <span class="fu">tex_fbm_for_terrain</span><span class="op">(</span><span class="dt">vec2</span> point<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>      <span class="co">// scale by 0.25 for a reasonably shaped terrain</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">// the +0.5 transforms it to 0..1 range - for the case of writing it to a non-float textures on older browsers or GLES3</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>      <span class="co">// add 0.5 only to noise, not to the derivatives</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>      <span class="co">// the y and z components of the addition vector are 0 since adding a constant</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>      <span class="co">// does not change the value of derivative</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>      <span class="dt">vec3</span> noise_val <span class="op">=</span> <span class="op">(</span><span class="fu">perlin_fbm</span><span class="op">(</span>point<span class="op">)</span> <span class="op">*</span> <span class="fl">0.25</span><span class="op">)</span> <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">0.</span><span class="op">);</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">return</span> noise_val<span class="op">;</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code></pre></div>
<p>The above code, present in <code>terrain.vert.glsl</code>
demonstrates this. The first function calculates <code>fbm</code> using
<code>perlin_noise</code> function. Note that the output of
<code>perlin_noise</code> function is a 3D vector whose x value
represents the noise value, and the y and z components represent the
derivative of the noise with respect to x and y respectively. This
derivative of perlin noise has to be propagated across the remaining
functions. In <code>perlin_fbm</code> function, the line
<code>fbm += vec3(new_octave.x, new_octave.yz * omega);</code>
propagates the gradient. The need to multiply by <code>omega</code> is
due to the chain rule.</p>
Finally in the function <code>tex_fbm_for_terrain</code>, the
<code>0.5</code> is added to transform the value from
<code>(-0.5, 0.5)</code> to <code>(0, 1)</code>. Here, we do not need to
transform the derivative, since a constant is being added to the noise.
Hence the y and z component of the additive vector in
<code>vec3 noise_val = (perlin_fbm(point) * 0.25) + vec3(0.5, 0., 0.);</code>
are <code>0</code>.
</details>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>Illusion of inifinite travel over the terrain</strong>
</summary>
<p>I observed that in the code for PG1, the variable
<code>mouse_offset</code> is being used for the viewer position. The key
point to complete this part was to note that the global position of a
point will be <code>position_in_the_mesh - mouse_offset</code>. So to
create an illusion of infinite terrain, I update the
<code>mouse_offset</code>. On pressing the
<code>LeftArrow</code>/<code>RightArrow</code> key, I update the
<code>X</code> coordinate of <code>mouse_offset</code> and on pressing
the <code>UpArrow</code>/<code>DownArrow</code> key, I update the
<code>Y</code> coordinate of <code>mouse_offset</code>.</p>
<p>After updating the <code>mouse_offset</code>, I set the variable
<code>update_needed</code> to be true, which re-renders the scene and
the landscape appears shifted.</p>
<h3 id="code-2">Code</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> step_size <span class="op">=</span> <span class="fl">2.</span><span class="op">/</span>GRID_HEIGHT</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(<span class="bu">event</span><span class="op">.</span><span class="fu">key</span> <span class="op">==</span> <span class="st">&#39;ArrowRight&#39;</span>) MouseCoordinates<span class="op">.</span><span class="at">mouse_offset_X</span> <span class="op">-=</span> step_size</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span>(<span class="bu">event</span><span class="op">.</span><span class="fu">key</span> <span class="op">==</span> <span class="st">&#39;ArrowLeft&#39;</span>) MouseCoordinates<span class="op">.</span><span class="at">mouse_offset_X</span> <span class="op">+=</span> step_size</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span>(<span class="bu">event</span><span class="op">.</span><span class="fu">key</span> <span class="op">==</span> <span class="st">&#39;ArrowUp&#39;</span>) MouseCoordinates<span class="op">.</span><span class="at">mouse_offset_Y</span> <span class="op">-=</span> step_size</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span>(<span class="bu">event</span><span class="op">.</span><span class="fu">key</span> <span class="op">==</span> <span class="st">&#39;ArrowDown&#39;</span>) MouseCoordinates<span class="op">.</span><span class="at">mouse_offset_Y</span> <span class="op">+=</span> step_size</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>update_needed <span class="op">=</span> <span class="kw">true</span></span></code></pre></div>
<p>Note that we cannot choose any step size here. It was carefully
chosen to be this value to allow the trees to move easily along with the
movement of terrain. As we will see next, I add trees onto the terrain
using instancing. The trees have been placed on vertices of the mesh. So
when the terrain is moved, the trees need to be moved such that the
vertex they remain on is fixed. Hence the step size is chosen as the
distance between two vertices of the mesh.</p>
</details>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>Instance rendering of simple meshes for birds / fish /
trees</strong>
</summary>
<p>I use the example <a
href="https://github.com/regl-project/regl/blob/gh-pages/example/instance-mesh.js">here</a>
to understand instancing. I use instance rendering to render trees and
birds.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">regl</span>({</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">attributes</span><span class="op">:</span> {       </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// instance attributes</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">offset</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;offset&#39;</span>)<span class="op">,</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">scale</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;scale&#39;</span>)<span class="op">,</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">model_c1</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;model_c1&#39;</span>)<span class="op">,</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">model_c2</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;model_c2&#39;</span>)<span class="op">,</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">model_c3</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;model_c3&#39;</span>)<span class="op">,</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">model_c4</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;model_c4&#39;</span>)<span class="op">,</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">...,</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">instances</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;num_instances&#39;</span>)<span class="op">,</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uniforms</span><span class="op">:</span> {</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">light_position</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;light_position&#39;</span>)<span class="op">,</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">view</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;view&#39;</span>)<span class="op">,</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">projection</span><span class="op">:</span> regl<span class="op">.</span><span class="fu">prop</span>(<span class="st">&#39;projection&#39;</span>)<span class="op">,</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>})</span></code></pre></div>
<p>Implementing this was the trickiest portion of the project as I
encountered various issues:</p>
<ul>
<li><strong>Finding tree mesh:</strong> Firstly, finding the suitable
mesh for the tree was a very tough task, since most of the files that I
found were of very large size and could not be rendered. Once I found
the mesh, I went through the pipeline of GL3 to understand how to use
that mesh.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> meshes_to_load <span class="op">=</span> [ <span class="st">&quot;tree2.obj&quot;</span><span class="op">,</span> <span class="st">&quot;bird2.obj&quot;</span> ]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(<span class="kw">const</span> mesh_name <span class="kw">of</span> meshes_to_load) {</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    resources[mesh_name] <span class="op">=</span> <span class="cf">await</span> <span class="fu">icg_mesh_load_obj_into_regl</span>(regl<span class="op">,</span> <span class="vs">`./meshes/</span><span class="sc">${</span>mesh_name<span class="sc">}</span><span class="vs">`</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li><strong>Size of trees:</strong> To make the trees of random sizes, I
scale the trees based on a random number generated using the tree’s
global coordinates.</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> scale <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">exp</span>(<span class="dv">1</span> <span class="op">/</span> (hash_num <span class="op">-</span> thresh)) <span class="op">*</span> scale_base</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Here the scale is a scaling factor for determining the size of the
tree.</p>
<p>I use an exponential function for this part, because it gave
sufficient variability in the different tree sizes.</p>
<ul>
<li>Passing model matrix: Since the trees are of different sizes, we
need a different <code>model_to_world</code> matrix for each tree. So
this variable is no longer a uniform, since it is different for every
tree rendered in the scene. In fact this is now an instance attribute. I
did not know that we can only pass primitive datatypes as attributes in
the regl framework (model matrix is a <code>mat4</code>). So I was stuck
for a long time in figuring out why is my code not working. Finally I
passed the columns of model matrix separately from the javascript files
and combined those columns in the shader code to make the model matrix.
Also, since I need the inverse of transpose of model view matrix, and
these functions are not supported by the WebGL API, I had to import the
implementation of these functions from the internet.</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>model_c1<span class="op">:</span> {</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">buffer</span><span class="op">:</span> models<span class="op">.</span><span class="fu">map</span>(model <span class="kw">=&gt;</span> model<span class="op">.</span><span class="fu">slice</span>(<span class="dv">0</span><span class="op">,</span> <span class="dv">4</span>))<span class="op">,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">divisor</span><span class="op">:</span> <span class="dv">1</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>}<span class="op">,</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>model_c2<span class="op">:</span> {</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">buffer</span><span class="op">:</span> models<span class="op">.</span><span class="fu">map</span>(model <span class="kw">=&gt;</span> model<span class="op">.</span><span class="fu">slice</span>(<span class="dv">4</span><span class="op">,</span> <span class="dv">8</span>))<span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">divisor</span><span class="op">:</span> <span class="dv">1</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>}<span class="op">,</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>model_c3<span class="op">:</span> {</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">buffer</span><span class="op">:</span> models<span class="op">.</span><span class="fu">map</span>(model <span class="kw">=&gt;</span> model<span class="op">.</span><span class="fu">slice</span>(<span class="dv">8</span><span class="op">,</span> <span class="dv">12</span>))<span class="op">,</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">divisor</span><span class="op">:</span> <span class="dv">1</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>}<span class="op">,</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>model_c4<span class="op">:</span> {</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">buffer</span><span class="op">:</span> models<span class="op">.</span><span class="fu">map</span>(model <span class="kw">=&gt;</span> model<span class="op">.</span><span class="fu">slice</span>(<span class="dv">12</span><span class="op">,</span> <span class="dv">16</span>))<span class="op">,</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">divisor</span><span class="op">:</span> <span class="dv">1</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>}<span class="op">,</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Then inside the shader:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>mat4 model <span class="op">=</span> mat4<span class="op">(</span>model_c1<span class="op">,</span> model_c2<span class="op">,</span> model_c3<span class="op">,</span> model_c4<span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>mat3 mat_normals <span class="op">=</span> inverse<span class="op">(</span>transpose<span class="op">(</span>mat3<span class="op">(</span>view <span class="op">*</span> model<span class="op">)));</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>The implementation of functions <code>inverse</code> and
<code>transpose</code> was taken from the internet.</p>
<ul>
<li>Positioning of trees: This was another challenge where I spent a lot
of time. I wanted to position the trees randomly on a terrain. Since the
landscape is infinite, when the landscape is scrolled, the trees are
expected to adjust accordingly. Therefore, the fact that a given point
in space should contain a tree should be a function of that point’s
global coordinates. The next hurdle is that if we use a noise function
such as the perlin noise function, it is a continuous function. So if a
tree exists at a point <code>(x, y)</code>, with very high probabililty
a tree will also exist at point <code>(x+dx, y+dy)</code>. So I needed a
function such that the probability a tree exists at <code>(x, y)</code>
is independent of the probability that the tree exists at
<code>(x+dx, y+dy)</code>. In other words, the function should be
discontinuous. One class of functions that satisfies this criteria are
the cryptographic hash functions. So I decided to use SHA256 hash
function using the <code>CryptoJS</code> library to calculate a hash
value for each point in the landscape. Then I threshold on the hash
value to determine if a tree should exist at that place. More details on
this can be found at the end of the report.</li>
<li>Calculating normals: For lighting the tree, I needed the normals of
the surface of the tree. Since the mesh that I found did not contain
these normals already, I had to calculate these myself. For every
triangular face of the mesh, I calculate the normal by taking the cross
product of the two sides of the triangle.</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// some meshes do not have face normals in the obj file</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">// so we calculate them from the verties here</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="kw">function</span> <span class="fu">build_mesh_normals</span>(mesh){</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// check if the mesh obj has face normals</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="pp">isNaN</span>(mesh<span class="op">.</span><span class="at">vertex_normals</span>[<span class="dv">0</span>])){</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        mesh<span class="op">.</span><span class="at">vertex_normals</span> <span class="op">=</span> []</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> mesh<span class="op">.</span><span class="at">faces</span><span class="op">.</span><span class="at">length</span><span class="op">/</span><span class="dv">3</span><span class="op">;</span> i<span class="op">++</span>){</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> idxs <span class="op">=</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>]<span class="op">.</span><span class="fu">map</span>(j <span class="kw">=&gt;</span> mesh<span class="op">.</span><span class="at">faces</span>[<span class="dv">3</span><span class="op">*</span>i <span class="op">+</span> j])</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> vertices <span class="op">=</span> idxs<span class="op">.</span><span class="fu">map</span>(j <span class="kw">=&gt;</span> mesh<span class="op">.</span><span class="at">vertex_positions</span><span class="op">.</span><span class="fu">slice</span>(<span class="dv">3</span><span class="op">*</span>j<span class="op">,</span> <span class="dv">3</span><span class="op">*</span>j<span class="op">+</span><span class="dv">3</span>))</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> line1 <span class="op">=</span> vec3<span class="op">.</span><span class="fu">sub</span>(vec3<span class="op">.</span><span class="fu">create</span>()<span class="op">,</span> vertices[<span class="dv">1</span>]<span class="op">,</span> vertices[<span class="dv">0</span>])</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> line2 <span class="op">=</span> vec3<span class="op">.</span><span class="fu">sub</span>(vec3<span class="op">.</span><span class="fu">create</span>()<span class="op">,</span> vertices[<span class="dv">2</span>]<span class="op">,</span> vertices[<span class="dv">0</span>])</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> normal <span class="op">=</span> vec3<span class="op">.</span><span class="fu">create</span>()<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            vec3<span class="op">.</span><span class="fu">cross</span>(normal<span class="op">,</span> line2<span class="op">,</span> line1)<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            mesh<span class="op">.</span><span class="at">vertex_normals</span><span class="op">.</span><span class="fu">push</span>(<span class="op">...</span>normal)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mesh<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</details>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>Animate birds/fish in an elaborate pattern, perhaps using noise
functions as velocity field.</strong>
</summary>
<p>This was relatively simple after having done instance rendering for
the trees. The key point here was to define the movement of the birds
using the noise functions to make the landscape more realistic.</p>
<p> The constants chosen in the code produced the best result with the 
birds varying their positions in all three dimensions at a reasonable speed. 
We also tune the constants that affect the z position in such a way that 
the birds fly close to the level of the terrain, but never so close that 
they fly "through" the terrain. Additionally, it is necessary to apply a 
sine function to the globalTime variable because it always increases. Without
the sine function, the birds' movement became more and more erratic over 
time and would eventually go off screen. </p>
</details>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>Bezier Curves</strong>
</summary>
I made the curves using the explicit (non-recursive) formula. The
function I made to calculate the bezier curve works for any number of
fixed points in the curve, however in the final curves I made I only
used sets of 5 points. Based on user input, the user can see one of
three curves: one circular around the center, and two of them making an
‘8’ like shape around the terrain. The ‘8’ shape is made using 4 bezier
curves, the terminal points being the center and one corner point. I
move the camera along this path and keep the camera target at a point
just ahead in the same shape (for these 2 paths). I also move ‘Mouse
Coordinates’ that simulate travel along the terrain to give a better
visual feel. I execute the continuous movement by calling the camera
movement function every few milliseconds, and I move along the curve on
the basis of time. Each curve is executed within one ‘second’ of a new
time variable that is a multiple of the globalTime, and the fractional
part of this ‘second’ provides the ‘t’ for the function that returns the
desired position of the camera. The main_terrain file can access
globalTime and can call the code to update the camera parameters, which
is why I wrote the code for this part here.
</details>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>Water Reflection</strong>
</summary>
I initially just created a 2D texture using a photo of the sky. I did
this by loading this texture, then adding it to the resources (so that I
can await the promise) and then making it a part of the uniforms. I
eventually scrapped this texture as it did not provide reflections.
Using 6 images of the sky that form a cubemap, I made a regl.cube object
and similarly to the 2D texture created a uniform for this cubemap that
I passed to the fragment shader as a samplerCube object. I calculated
the reflected direction using the view vector (which now had to take
into account the camera target since it is not always the center) and
the surface normals, which I had to manually implement as the the
position of the water was a non-trivial function of the 2D noise we had
used. Then, I used the textureCube function to apply the cubemap to the
points in the water.
</details>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>Setting up globalTime variable</strong>
</summary>
Since our project involves animations with animated water waves and
Bézier curves, it was important to set up a time variable that was
continuously changing. This was done in the main_terrain.js file, where
it is initialized to zero. The variable gets incremented in the frame
render loop, where it is possible to set it to the time attribute of the
frame, which increases linearly. Then, the variable is stored as a
uniform so that it can be used in the glsl files.
</details>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>3D waves and 3D Perlin noise</strong>
</summary>
<p>3D Perlin noise is implemented by extending the method for 2D Perlin
noise into the third dimension. There are now eight integer points in
the lattice surrounding a point and interpolation must be done between
the contributions of each. The code for 3D Perlin noise was taken from
this website and no modifications were made to it.</p>
<p>To implement the animated waves, the 3D Perlin noise function is
called in the terrain vertex shader file. When a vertex’s z-position is
below the water level, its position is transformed by first a call to a
sine function to create a sinusoidal wave effect. This is then
multiplied by a call to the 3D Perlin noise function, which takes the
time variable as input, in order to introduce variation and
pseudo-randomness to the wave. Finally, the modified position is
transformed by the model-view-projection matrix to render the new
position onto the screen.</p>
<p>Of course, modifying the water’s vertex positions must constantly be
done to produce a smooth animation. Thus, in the main_terrain.js file,
the init_terrain function is modified to be called every 33.3
milliseconds (or 30 frames per second) rather than just once. The
update_needed boolean is also set to true, allowing the code that
updates the time variable in the render loop to run. This allows the
water vertex positions to constantly change to create the wave
effect.</p>
<p>See the results section below for the resulting wave animation.</p>
<p>Problems encountered:</p>
There were several initial attempts to create animated waves which
failed. The first attempt involved trying to edit the fragment shader
file in order to change the color of the water. This did not work
because we only managed to get all the water pixels to change to the
same color rather than each individual pixel. Additionally, it was not
possible to change the height of the water here to create the wave
effect. Another attempt involved trying to dynamically change the water
level threshold based on position in the mesh.js file. However, we were
not able to incorporate the time variable here. The third attempt was
the correct solution, which is the modification of the vertex positions
described above.
</details>
<h1 id="results">Results</h1>
<p><strong>Screenshot of overall view of the project</strong></p>
<figure>
<img src="images/Overall view.png" width="600" alt="Overall view of the project" />
<figcaption aria-hidden="true">
Overall view of the project
</figcaption>
</figure>
<p><strong>Illusion of infinite terrain and tree instance rendering</strong></p>
<figure>
<video src="images/Infinite terrain.mp4" width="600" controls="">
<a href="images/Infinite terrain.mp4">Use the arrow keys to move infinitely in any direction</a>
</video>
<figcaption aria-hidden="true">Use the arrow keys to move infinitely in any direction. We also see the trees being generated at random locations on ground and of random sizes.
</figcaption>
</figure>
<p><strong>Instance rendering and animation of birds</strong></p>
<figure>
<video src="images/animated_birds.mp4" width="600" controls="">
<a href="images/animated_birds.mp4">Birds with pseudo random movements in three dimensions</a>
</video>
<figcaption aria-hidden="true">Birds with pseudo random movements in three dimensions
</figcaption>
</figure>
<p><strong>Bézier curves</strong></p>
<figure>
<video src="images/bezier_1.mov" width="600" controls>
<a href="images/bezier_1.mov">Bézier curve #1</a>
</video>
<figcaption aria-hidden="true">
Bézier curve #1
</figcaption>
</figure>
<figure>
<video src="images/bezier_2.mov" width="600" controls>
<a href="images/bezier_2.mov">Bézier curve #2</a>
</video>
<figcaption aria-hidden="true">
Bézier curve #2
</figcaption>
</figure>
<figure>
<video src="images/bezier_3.mov" width="600" controls>
<a href="images/bezier_3.mov">Bézier curve #3</a>
</video>
<figcaption aria-hidden="true">
Bézier curve #3
</figcaption>
</figure>
<p><strong>Water reflection and animation</strong></p>
<figure>
<video src="images/water_animation.mov" width="600" controls="">
<a href="images/water_animation.mov">Bézier curve #3</a>
</video>
<figcaption aria-hidden="true">Water waves and the reflection of sky from a cubemap
</figcaption>
</figure>
<h1 id="contributions">Contributions</h1>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Team Member</th>
<th>Work Done</th>
<th>%age contribution of total workload</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Gurnoor</td>
<td>Understood the working of regl pipeline, implemented the terrain
shape and normals in vertex shader. Created the illusion of infinite
travel on the terrain. Rendered randomly placed trees of different sizes
using instancing in regl. Rendered the birds and gave them
animation.</td>
<td>40%</td>
</tr>
<tr class="even">
<td>Lawrence</td>
<td>Researched 3D Perlin noise, implemented and set up the globalTime
variable, implemented animated waves, helped with bird animation, and
voiced the video presentation.</td>
<td>27%</td>
</tr>
<tr class="odd">
<td>Aayush</td>
<td>Implemented Bézier curve animations and water reflections using the
cubemap, applied proper reflection to the animated waves, edited the
video presentation.</td>
<td>33%</td>
</tr>
</tbody>
</table>
<h1 id="resources">Resources</h1>
<p>Implementing noise on GPU:
http://www.sci.utah.edu/~leenak/IndStudy_reportfall/Perlin%20Noise%20on%20GPU.html</p>
<p>Texture Generation:
https://www.redblobgames.com/maps/terrain-from-noise/</p>
<p>CS-341 Exercise PG-1:
https://moodle.epfl.ch/mod/assign/view.php?id=1065258</p>
<p>Implementing 3D Perlin Noise for Clouds:
https://www.cs.carleton.edu/cs_comps/0405/shape/marching_cubes.html</p>
<p>3D Perlin noise function:
https://gpfault.net/posts/perlin-noise.txt.html</p>
<p>Water 2D Texture (Unused finally):
https://www.freepik.com/free-vector/abstract-blue-sky-background_37272502.htm#query=sky%20texture&amp;position=5&amp;from_view=keyword&amp;track=ais</p>
<p>Understanding shaders and GL pipeline:
https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html</p>
<p>Understanding shaders and GL pipeline:
https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html</p>
<p>Understanding shaders and GL pipeline:
https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html</p>
<p>Creating illusion of inifinite terrain:
https://github.com/raveenajain/Infinite-Terrain</p>
<p>Creating illusion of infinite terrain:
https://www.youtube.com/watch?v=NPyPkpYyxXI&amp;ab_channel=IanBarnard</p>
<p>Derivative of perlin noise:
https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2/perlin-noise-computing-derivatives.html</p>
<p>Derivative of perlin noise:
https://iquilezles.org/articles/gradientnoise/</p>
<p>Function for transpose of a matrix in glsl:
https://stackoverflow.com/questions/18034677/transpose-a-mat4-in-opengl-es-2-0-glsl</p>
<p>Function for inverse of a matrix in glsl:
https://github.com/glslify/glsl-inverse/blob/master/index.glsl</p>
<p>Meshes for trees and birds: these were downloaded for free from
results obtained from google search. Since I was facing some issues with
using these initially, I had to try multiple meshes, and I do not have
the link to the mesh I am using right now. But I declare that the tree
and bird mesh obj files are not my own work.</p>
<h1 id="miscellaneous">Miscellaneous</h1>
<details>
<summary style="cursor:pointer; font-size: 24px">
<strong>Details regarding positioning of trees in the terrain</strong>
</summary>
<p>As described above in the report, the condition to be satisfied while
placing the trees was that they should be placed randomly. For that I
needed a discontinuous random function, by which I mean that the value
of the function at <code>(x, y)</code> is independent of the value
function at the neighouring points. Cryptographic hash functions satisfy
this property. But the issue is that we are passing the <em>global
coordinates</em> of the point as input to the function. Since the global
coordinates have been calculated by subtracting the viewer position
(<code>mouse_offset</code>) from the coordinates of the point in mesh,
due to precision limitations of javascript, the global coordinates
obtained are not always exactly the same. What I mean by this is that if
a point has a global coordinate <code>(0.5, 0.5)</code>, when the
terrain is moved slightly, its coordinates may become
<code>(0.499999, 0.4999999)</code>. Since the hash functions are not
resistant to this, the value of hash changes and if there existed a tree
at <code>(0.5, 0.5)</code> before, it may not exist now at
<code>(0.499999, 0.4999999)</code>.</p>
<p>To fix this, I observed that we need to convert the mesh points in
the range <code>(-0.5, 0.5)</code> into their original range
<code>(0, GRID_SIZE-1)</code>. So basically I use the inverse of the
function <code>terrain_build_mesh</code> in <code>mesh.js</code> to map
the global coordinates of a point in the terrain to an integer, to make
it resistant to floating point precision errors.</p>
<p>The following code demonstrates this</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="kw">function</span> <span class="fu">get_positions</span>(thresh<span class="op">,</span> terrain_mesh<span class="op">,</span> scale_base<span class="op">=</span><span class="dv">1</span><span class="op">/</span><span class="dv">20</span><span class="op">,</span> birds<span class="op">=</span><span class="kw">false</span>){</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> terrain_mesh<span class="op">.</span><span class="at">vertex_positions</span><span class="op">.</span><span class="at">length</span><span class="op">;</span> i<span class="op">++</span>){</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> terrain_point <span class="op">=</span> terrain_mesh<span class="op">.</span><span class="at">vertex_positions</span>[i]<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> terrain_point[<span class="dv">0</span>] <span class="op">-</span>   MouseCoordinates<span class="op">.</span><span class="at">mouse_offset_X</span><span class="op">/</span><span class="dv">2</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y <span class="op">=</span> terrain_point[<span class="dv">1</span>] <span class="op">-</span>   MouseCoordinates<span class="op">.</span><span class="at">mouse_offset_Y</span><span class="op">/</span><span class="dv">2</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// in this step, we cannot simply use Math.round(x * 100)</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// or some other function as that gives the floating point precision</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// error as described above</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">round</span>((x <span class="op">+</span> MIN_TERRAIN_VAL) <span class="op">*</span> GRID_HEIGHT)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">round</span>((y <span class="op">+</span> MIN_TERRAIN_VAL) <span class="op">*</span> GRID_WIDTH)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">var</span> hash <span class="op">=</span> CryptoJS<span class="op">.</span><span class="fu">SHA256</span>(x<span class="op">.</span><span class="fu">toString</span>() <span class="op">+</span> y<span class="op">.</span><span class="fu">toString</span>())<span class="op">;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// hash is a hex string, need to convert it to an integer</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we use .slice(6) to take only 6 characters of the hash for a faster</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// conversion to int</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// modulo 2047 is done to bring the number to a reasonable range</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">var</span> hash_num <span class="op">=</span> <span class="pp">parseInt</span>(hash<span class="op">.</span><span class="fu">toString</span>(CryptoJS<span class="op">.</span><span class="at">enc</span><span class="op">.</span><span class="at">Hex</span>)<span class="op">.</span><span class="fu">slice</span>(<span class="dv">6</span>)<span class="op">,</span> <span class="dv">16</span>) <span class="op">%</span> <span class="dv">2047</span><span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span>   </span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</details>
</body>
</html>
